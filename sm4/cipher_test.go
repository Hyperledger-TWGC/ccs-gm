package sm4

import (
	"bytes"
	"fmt"
	"log"
	"testing"
)

func TestBlockBase(t *testing.T){
	var tests = []struct{
		key []byte
		msg []byte
		want []byte
		isEnc bool
	}{
		{
			key:[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10},
			msg:[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10},
			want: []byte{0x68,0x1E,0xDF,0x34,0xD2,0x06,0x96,0x5E,0x86,0xB3,0xE9,0x4F,0x53,0x6E,0x42,0x46},
			isEnc: true,
		},
		{
			key:[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10},
			msg:[]byte{0x68,0x1E,0xDF,0x34,0xD2,0x06,0x96,0x5E,0x86,0xB3,0xE9,0x4F,0x53,0x6E,0x42,0x46},
			want:[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10},
			isEnc: false,
		},
	}
	for _, test:= range tests{
		block,err := NewCipher(test.key)
		if err != nil {
			t.Errorf("new cipher failed:%s\n", err.Error())
			continue
		}
		dst := make([]byte, 16)
		if test.isEnc{
			block.Encrypt(dst, test.msg)
		}else{
			block.Decrypt(dst, test.msg)
		}
		if !bytes.Equal(test.want, dst){
			t.Errorf("TestBlockBase failed:\n key:%v\n msg:%v\n want:%v\n actual:%v\n", test.key, test.msg, test.want, dst)
		}
	}
}


func TestSM4(t *testing.T) {
	key := []byte("1234567890abcdef")
	fmt.Printf("key = %v\n", key)
	data := []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10}
	fmt.Printf("key = %v\n", key)
	fmt.Printf("data = %x\n", data)
	c, err := NewCipher(key)
	if err != nil {
		log.Fatal(err)
	}
	d0 := make([]byte, 16)
	c.Encrypt(d0, data)
	fmt.Printf("d0 = %x\n", d0)
	d1 := make([]byte, 16)
	c.Decrypt(d1, d0)
	fmt.Printf("d1 = %x\n", d1)
}
